<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lion_Liu</title>
  <subtitle>一名专业的iOS程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lionwy.github.io/"/>
  <updated>2016-10-31T09:42:06.000Z</updated>
  <id>http://lionwy.github.io/</id>
  
  <author>
    <name>Lion_Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片加载之SDWebImage（下）</title>
    <link href="http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BSDWebImage%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://lionwy.github.io/图片加载之SDWebImage（下）/</id>
    <published>2016-10-31T09:30:05.000Z</published>
    <updated>2016-10-31T09:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇留下的两个入口接着深入分析，图片缓存<code>SDImageCache</code>和图片下载<code>SDWebImageDownloader</code>以及下载操作<code>SDWebImageDownloaderOperation</code></p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/work.jpg" alt=""></p>
<h2 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h2><blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.</p>
</blockquote>
<p><code>SDImageCache</code>包含内存缓存以及磁盘缓存。其中，磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟</p>
<h3 id="查找缓存图片"><a href="#查找缓存图片" class="headerlink" title="查找缓存图片"></a>查找缓存图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<ol>
<li><p>确定<code>key</code>值，实际上就是<code>url.absoluteString</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"></div><div class="line"><span class="comment">// 如果key不存在，直接返回</span></div><div class="line">   <span class="keyword">if</span> (!key) &#123;</div><div class="line">       <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">           doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第一次在内存中查找：<br>内部其实是通过<code>NSCache</code>来获取和存储的</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIImage *<span class="built_in">image</span> = [self imageFromMemoryCacheForKey:<span class="built_in">key</span>];</div><div class="line">// 方法内部实现：memCache 是 NSCache类型</div><div class="line">// <span class="built_in">return</span> [self.memCache objectForKey:<span class="built_in">key</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>查找到图片之后的操作<br>其中，内存很快，几乎不需要时间，所以不需要一个执行任务，返回<code>operation</code>为nil</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">// 是否是gif图片，实际判断图片对应的数组是否为空</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            <span class="comment">// 在磁盘缓存中根据key获取图片的data</span></div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            <span class="comment">// 查询完成，缓存设置为SDImageCacheTypeMemory</span></div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内存找不到的情况下，第二次在磁盘中查询<br>磁盘查找比较耗时，所以需要创建一个执行任务<code>operation</code><br><code>ioQueue</code>是一个串行队列，这里新开线程，异步执行,不会阻塞UI</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 磁盘文件IO会增大内存消耗，放在自动释放池中，降低内存峰值</span></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="comment">// 通过key获取文件路径，然后通过文件路径获取data，其中文件路径内部是通过md5加密的</span></div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 内部实现也是先获取data，然后转换成Image，其中image是经过解压缩，根据屏幕同比例增大，甚至在必要情况下，解码重绘得到的，</span></div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="comment">// 获取图片所占内存大小</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                <span class="comment">// 在磁盘中找到图片，先放入内存中，以便下次直接使用</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 查询结束返回更新UI</span></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    <span class="comment">// 查询完成，返回缓存设置为SDImageCacheTypeDisk</span></div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">   &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缓存存储图片"><a href="#缓存存储图片" class="headerlink" title="缓存存储图片"></a>缓存存储图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure>
<ol>
<li><p>首先进行内存缓存，通过<code>NSCache</code>的<code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</code>方法，</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 图片或者<span class="built_in">key</span>不存在的情况下，直接返回</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">image</span> || !<span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    // <span class="keyword">if</span> memory cache <span class="built_in">is</span> enabled</div><div class="line">    // 内存缓存</div><div class="line">    <span class="keyword">if</span> (self.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        NSUInteger cost = SDCacheCostForImage(<span class="built_in">image</span>);</div><div class="line">        </div><div class="line">        [self.memCache setObject:<span class="built_in">image</span> forKey:<span class="built_in">key</span> cost:cost];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>磁盘缓存，通过<code>NSFileManager</code>把文件存储磁盘</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (toDisk) &#123;</div><div class="line">        <span class="selector-tag">dispatch_async</span>(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">            </div><div class="line">            <span class="selector-tag">if</span> (!data &amp;&amp; image) &#123;</div><div class="line">                <span class="comment">// 1. 根据data确定图片的格式，png/jpeg</span></div><div class="line">                SDImageFormat imageFormatFromData = <span class="selector-attr">[NSData sd_imageFormatForImageData:data]</span>;</div><div class="line">                <span class="comment">// 2. 格式不同，转换data的方式不同，</span></div><div class="line">                data = <span class="selector-attr">[image sd_imageDataAsFormat:imageFormatFromData]</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 3. 磁盘缓存，内部会做很多工作，是否io队列，创建文件夹，图片名字加密，是否存储iCloud，</span></div><div class="line">            [self <span class="attribute">storeImageDataToDisk</span>:data <span class="attribute">forKey</span>:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 磁盘缓存需要时间，异步执行completionBlock，通知存储已经结束</span></div><div class="line">            if (completionBlock) &#123;</div><div class="line">                <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completionBlock();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>回调<code>completeBlock</code>通知外部，存储已经完成</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">  completionBlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缓存清除"><a href="#缓存清除" class="headerlink" title="缓存清除"></a>缓存清除</h3><p>通过上面已经知道，内存缓存是使用<code>NSCache</code>，磁盘缓存是使用<code>NSFileManager</code>，所以缓存清除，对应的内存清除<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.memCache removeObjectForKey:key]</div></pre></td></tr></table></figure></p>
<p>磁盘清除<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil]</div></pre></td></tr></table></figure></p>
<h2 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h2><blockquote>
<p>Asynchronous downloader dedicated and optimized for image loading</p>
</blockquote>
<p>优化过的专门用于加载图片的异步下载器<br>核心方法是：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(nullable SDWebImageDownloadToken *)</span>downloadImageWithURL:<span class="params">(nullable NSURL *)</span>url</div><div class="line">                                                   options:<span class="params">(SDWebImageDownloaderOptions)</span>options</div><div class="line">                                                  progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</div><div class="line">                                                 completed:<span class="params">(nullable SDWebImageDownloaderCompletedBlock)</span>completedBlock;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>方法需要返回一个<code>SDWebImageDownloadToken</code>对象，它跟下载器一一对应，可以被用来取消对应的下载。它有两个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *url; <span class="comment">// 当前下载器对应的url地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> downloadOperationCancelToken; <span class="comment">// 一个任意类型的对象，</span></div></pre></td></tr></table></figure>
</li>
<li><p>深入方法，内部实现其实是调用另一个方法。<br>该方法，用来添加各个回调方法block的。<br>而调用该一个方法，需要一个参数<code>SDWebImageDownloaderOperation</code>对象，block内部就是创建这个对象的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> [self <span class="string">addProgressCallback:</span>progressBlock <span class="string">completedBlock:</span>completedBlock <span class="string">forURL:</span>url <span class="string">createCallback:</span>^SDWebImageDownloaderOperation *&#123; </div><div class="line">		<span class="comment">// 内部返回一个SDWebImageDownloaderOperation对象</span></div><div class="line">		<span class="comment">// 创建</span></div><div class="line">		SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] <span class="string">initWithRequest:</span>request <span class="string">inSession:</span>sself.session <span class="string">options:</span>options];</div><div class="line">		<span class="comment">// 返回</span></div><div class="line">		<span class="keyword">return</span> operation;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><code>SDWebImageDownloaderOperation</code>继承于<code>NSOperation</code>，用来执行下载操作的。下面创建<code>SDWebImageDownloaderOperation</code>对象</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置请求时间限制</span></div><div class="line">  NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">  <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">      timeoutInterval = <span class="number">15.0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">  <span class="comment">// 这里防止重复缓存，默认是阻止网络请求的缓存。</span></div><div class="line">  <span class="comment">// 创建网络请求request，并设置网络请求的缓存策略 ，是否使用网络缓存</span></div><div class="line">  NSMutableURLRequest *request = [[NSMutableURLRequest alloc] <span class="string">initWithURL:</span>url <span class="string">cachePolicy:</span>(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) <span class="string">timeoutInterval:</span>timeoutInterval];</div><div class="line">  <span class="comment">// 是否发送cookie</span></div><div class="line">  request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">  </div><div class="line">  <span class="comment">// 是否等待之前的返回响应，然后再发送请求</span></div><div class="line">  <span class="comment">// YES, 表示不等待</span></div><div class="line">  request.HTTPShouldUsePipelining = YES;</div><div class="line">  </div><div class="line">  <span class="comment">// 请求头</span></div><div class="line">  <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">      request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">      request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 初始化一个图片下载操作，只有放入线程，或者调用start才会真正执行请求</span></div><div class="line">  <span class="comment">// 这里真正创建SDWebImageDownloaderOperation，</span></div><div class="line">  SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] <span class="string">initWithRequest:</span>request <span class="string">inSession:</span>sself.session <span class="string">options:</span>options];</div></pre></td></tr></table></figure>
</li>
<li><p>对下载操作<code>operation</code>的属性设置，并安排下载操作的优先级以及执行顺序</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩图片</span></div><div class="line">   operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">   </div><div class="line">   <span class="comment">// 对应网络请求设置请求凭证</span></div><div class="line">   <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">       operation.credential = sself.urlCredential;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">       operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>sself.username <span class="string">password:</span>sself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 操作执行的优先级</span></div><div class="line">   <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">       operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">       operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 下载队列添加下载操作</span></div><div class="line">   [sself.downloadQueue <span class="string">addOperation:</span>operation];</div><div class="line">   </div><div class="line">   <span class="comment">// 根据执行顺序，添加依赖</span></div><div class="line">   <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">       <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">       [sself.lastAddedOperation <span class="string">addDependency:</span>operation];</div><div class="line">       </div><div class="line">       sself.lastAddedOperation = operation;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分析第2步中，添加各个回调block的方法。<br>这个方法最终操作，是返回 <code>SDWebImageDownloadToken</code>对象</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 所有的下载操作都是以一个真实的url为前提，一旦url为<span class="keyword">nil</span>，直接返回<span class="keyword">nil</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="keyword">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="keyword">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="type">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 方法最终是要返回<span class="type">SDWebImageDownloadToken</span>对象，这里声明，并使用__block修饰，以便在后续<span class="keyword">block</span>中进行修改赋值</div><div class="line">    __block <span class="type">SDWebImageDownloadToken</span> *token = <span class="keyword">nil</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>使用GCD中的栅栏，来保证字典写入操作不会发生冲突。其中涉及到一个属性<code>URLOperations</code>，类型为<code>NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt;</code>，用来存储url对应的下载操作。<br><strong>注意其中的a点，这里是把对应于同一个<code>url</code>的多个下载操作，合并为一个，就是说，如果有多张<code>ImageView</code>对应于一个<code>url</code>，实际上执行一个下载操作，但他们的进度和完成block还是分开处理的，后续才有数组<code>callbackBlocks</code>来存储所有的blocks，当下载完成后，所有的block执行回调。当然，<em>前提是操作未结束</em>，还没执行<code>completionBlock</code>。</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 多线程中的栅栏，barrierQueue 是一个并行队列</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// a. 根据url判断是否有对应的operation</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 如果没有，就赋值，createCallback()就是之前第3步创建的SDWebImageDownloaderOperation对象</span></div><div class="line">            operation = createCallback();</div><div class="line">            </div><div class="line">            <span class="comment">// 对应于a操作，赋值，存储</span></div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line"></div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            <span class="comment">// 设置完成之后的回调</span></div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              </div><div class="line">                SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              </div><div class="line">                <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">            </div><div class="line">                <span class="comment">// 操作已经结束了，移除该操作</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  </div><div class="line">                    [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              </div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 创建最终需要返回的对象，内部实现往下看</span></div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line"></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h2><blockquote>
<p><code>SDWebImageDownloaderOperation</code>继承于<code>NSOperation</code>，并实现了<code>&lt;SDWebImageDownloaderOperationInterface&gt;</code>协议，专门用来执行下载操作任务的。</p>
</blockquote>
<ol>
<li><p>对于上述第6点中的，添加存储下载进度的回调block和完成回调block。<br>涉及到一个隐藏属性<code>callbackBlocks</code>，类型为<code>NSMutableArray&lt;SDCallbacksDictionary *&gt;</code>，用来存储进度回调和完成回调的block<br>所有对应于url的执行任务的回调block，都存储其中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">		 <span class="comment">// 可变字典 typedef NSMutableDictionary&lt;NSString *, id&gt; SDCallbacksDictionary;</span></div><div class="line">	    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">	    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">	    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">	    <span class="comment">// 使用栅栏，安全添加回调字典，</span></div><div class="line">	    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">	        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">	    &#125;);</div><div class="line">	    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当<code>operation</code>添加进队列<code>downloadQueue</code>中后，会自动调用<code>start</code>方法，下面分析该方法<br>一旦操作取消，立马重置所有属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">       <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">       <span class="comment">// 内部会移除所有回调block，属性置空</span></div><div class="line">       [<span class="keyword">self</span> reset];</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>进入后台后继续执行网络请求任务。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if SD_UIKIT </span></div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="comment">// 进入后台后也允许继续执行请求</span></div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="comment">// 开启后台执行任务</span></div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="comment">// 后台执行是有时间限制的，当时间到期时，取消所有任务，关闭后台任务，并使之失效。</span></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建数据请求任务</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iOS 7 以后，使用NSURLSession 来进行网络请求</span></div><div class="line">   <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</div><div class="line">       <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">       <span class="comment">// 请求时间</span></div><div class="line">       sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">       </div><div class="line">       <span class="comment">/**</span></div><div class="line">        *  Create the session for this task</div><div class="line">        *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</div><div class="line">        *  method calls and completion handler calls.</div><div class="line">        */</div><div class="line">       <span class="comment">// 针对当前任务，创建session，</span></div><div class="line">       <span class="comment">// 这里代理队列为nil，所以，session创建一个串行操作队列，同步执行所有的代理方法和完成block回调</span></div><div class="line">       <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                         delegate:<span class="keyword">self</span></div><div class="line">                                                    delegateQueue:<span class="literal">nil</span>];</div><div class="line">       session = <span class="keyword">self</span>.ownedSession;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 创建数据请求任务</span></div><div class="line">   <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line">   <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>任务开始执行<br>这里使用<code>@synchronized</code>，防止其他线程同时进行访问、处理。<br><code>self.dataTask</code>每次只能创建一个，不能同时创建多个</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@synchronized</span> (self) &#123; &#125;;</div><div class="line"><span class="comment">// 任务执行，请求发送</span></div><div class="line"><span class="selector-attr">[self.dataTask resume]</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>任务刚开始执行时候的处理</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">        <span class="comment">// 任务刚开始执行，同一个url对应的所有progressBlocks，进行一次信息回调。</span></div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回主线程发送通知，任务开始执行</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 如果任务不存在，回调错误信息，“请求链接不存在”</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;]];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>任务已经开始执行，后台任务就没必要存在了，关闭后台任务并使之失效</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if SD_UIKIT</span></div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>数据请求，任务执行过程中，代理方法的各种回调<br> a. 任务已经获取完整的返回数据</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span></div><div class="line">          <span class="selector-tag">dataTask</span><span class="selector-pseudo">:(NSURLSessionDataTask</span> *)<span class="selector-tag">dataTask</span></div><div class="line"><span class="selector-tag">didReceiveResponse</span><span class="selector-pseudo">:(NSURLResponse</span> *)<span class="selector-tag">response</span></div><div class="line"> <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(NSURLSessionResponseDisposition disposition))<span class="selector-tag">completionHandler</span> &#123;</div><div class="line">	 	</div><div class="line">	 	<span class="comment">/*</span></div><div class="line">	 	 1. 进度回调一次，把图片完整大小传出去</div><div class="line">	 	 2. 发送通知，已经收到图片数据了</div><div class="line">	 	 3. 如果失败，取消任务，并重置，发送通知，以及回调错误信息</div><div class="line">	 	*/ </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> b. 网络数据接收过程中 </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">dataTask</span><span class="selector-pseudo">:(NSURLSessionDataTask</span> *)<span class="selector-tag">dataTask</span></div><div class="line">                                     <span class="selector-tag">didReceiveData</span><span class="selector-pseudo">:(NSData</span> *)<span class="selector-tag">data</span> &#123;</div><div class="line">	  </div><div class="line">	  <span class="comment">/*</span></div><div class="line">		1. data 拼接</div><div class="line">		2. 如果需要，图片一节一节的显示</div><div class="line">		3. 进度不断回调</div><div class="line">		*/</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> c. 主要用来进行网络数据缓存的处理</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">task</span><span class="selector-pseudo">:(NSURLSessionTask</span> *)<span class="selector-tag">task</span></div><div class="line">                            <span class="selector-tag">didReceiveChallenge</span><span class="selector-pseudo">:(NSURLAuthenticationChallenge</span> *)<span class="selector-tag">challenge</span> </div><div class="line">                              <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))<span class="selector-tag">completionHandler</span> &#123;</div><div class="line"> </div><div class="line">		 <span class="comment">/*</span></div><div class="line">		 	 进行非网络缓存的处理，或者进行特定的网络缓存处理</div><div class="line">		 */</div><div class="line"> </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> d. 刚接收完最后一条数据时调用的方法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">task</span><span class="selector-pseudo">:(NSURLSessionTask</span> *)<span class="selector-tag">task</span> <span class="selector-tag">didCompleteWithError</span><span class="selector-pseudo">:(NSError</span> *)<span class="selector-tag">error</span> &#123; </div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		1. 发送通知，任务完成，停止任务</div><div class="line">		2. 图片处理并回调completionBlock</div><div class="line">		3. 任务完成</div><div class="line">		*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/SDWebImageDownload.jpeg" alt="SDWebImageDownloader &amp;&amp; SDWebImageDownloaderOperation"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. <code>SDImageCache</code>主要是用来管理所有图片缓存相关方法的类，包括存储、获取、移除等</em></strong></p>
<p><strong><em>2. <code>SDWebImageDownloader</code>主要是用来处理生成<code>SDWebImageDownloaderOperation</code>的类，管理图片下载对应的操作，以及操作的一些属性设置。</em></strong></p>
<p><strong><em>3. <code>SDWebImageDownloaderOperation</code>用来管理数据网络请求的类，并把请求结果进行处理回调。</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇留下的两个入口接着深入分析，图片缓存&lt;code&gt;SDImageCache&lt;/code&gt;和图片下载&lt;code&gt;SDWebImageDownloader&lt;/code&gt;以及下载操作&lt;code&gt;SDWebImageDownloaderOperation&lt;/code&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="源码" scheme="http://lionwy.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="图片" scheme="http://lionwy.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="SDWebImage" scheme="http://lionwy.github.io/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>图片加载之SDWebImage（上）</title>
    <link href="http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BSDWebImage%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://lionwy.github.io/图片加载之SDWebImage（上）/</id>
    <published>2016-10-28T08:21:21.000Z</published>
    <updated>2016-10-28T08:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Asynchronous image downloader with cache support as a UIImageView category</p>
</blockquote>
<p>支持图片异步下载和缓存的UIImageView分类</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/light.jpg" alt=""></p>
<h2 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView+WebCache"></a>UIView+WebCache</h2><ol>
<li><p>最基本的方法是<code>UIImageView+WebCache</code>中这个方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div></pre></td></tr></table></figure>
</li>
<li><p>一步步走下来，会发现实际运用的是<code>UIView+WebCache</code>中的方法，包括<code>UIButton+WebCache</code>内部核心方法也是调用的下面的方法，其中<code>SDWebImageOptions</code>策略详细介绍可以看<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/SourceCode/SourceCode/libs/SDWebImage/SDWebImageManager.h" target="_blank" rel="external">这里</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
</li>
<li><p>进入方法内部：先取消相关的所有下载</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  operationKey  用来描述当前操作的关键字标识，默认值是类名字，即 @"UIImageView"</span></div><div class="line"><span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 取消当前view下 跟validOperationKey有关的所有下载操作，以保证不会跟下面的操作有冲突</span></div><div class="line">[<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line"></div><div class="line"><span class="comment">// 通过runtime的关联对象给UIView添加属性，设置图片地址</span></div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div></pre></td></tr></table></figure>
<p>其中取消操作方法内部涉及到一个协议<code>&lt;SDWebImageOperation&gt;</code>，这个协议只有一个<code>cancel</code>方法，可见，这个协议就是用来取消操作的，只要遵守该协议的类，必定会有<code>cancel</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">	- (<span class="keyword">void</span>)cancel;</div><div class="line"></div><div class="line">	<span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>取消方法的具体实现：<br>涉及到一个字典<code>SDOperationsDictionary</code>类型为<code>NSMutableDictionary&lt;NSString *, id&gt;</code>，也是通过关联对象添加为UIView的属性，用来存储UIView的所有下载操作，方便之后的取消/移除</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 从队列中取消跟key有关的所有下载操作</span></div><div class="line">	    <span class="comment">// 任何实现协议的对象都执行取消操作</span></div><div class="line">	    SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line">	    <span class="keyword">id</span> operations = operationDictionary[key];</div><div class="line">	    <span class="keyword">if</span> (operations) &#123;</div><div class="line">	        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">		        </div><div class="line">	            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</div><div class="line">	                <span class="keyword">if</span> (operation) &#123;</div><div class="line">	                    [operation cancel];</div><div class="line">	                &#125;</div><div class="line">	            &#125;</div><div class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</div><div class="line">	            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">	        &#125;</div><div class="line">	        <span class="comment">// 最后从字典中移除key</span></div><div class="line">	        [operationDictionary removeObjectForKey:key];</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果没有设置延迟加载占位图<code>SDWebImageDelayPlaceholder</code>，就会先进行加载占位图，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">	   <span class="selector-tag">dispatch_main_async_safe</span>(^&#123;</div><div class="line">     	       </div><div class="line">            <span class="comment">// 返回主线程中进行UI设置，把占位图当成image进行图片设置，在方法内部会进行UIButton和UIImageView的判断区分</span></div><div class="line">            <span class="selector-attr">[self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中有一个宏定义，通过字符串的比较来获取主线程</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ifndef dispatch_main_async_safe</span></div><div class="line"><span class="comment">#define dispatch_main_async_safe(block)\</span></div><div class="line">	    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;<span class="string">\</span></div><div class="line">	        block();<span class="string">\</span></div><div class="line">	    &#125; <span class="keyword">else</span> &#123;<span class="string">\</span></div><div class="line">	        dispatch_async(dispatch_get_main_queue(), block);<span class="string">\</span></div><div class="line">	    &#125;</div><div class="line"><span class="comment">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>判断url，url为空的情况下，直接返回错误信息</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (url) &#123;</div><div class="line">       <span class="comment">// check if activityView is enabled or not</span></div><div class="line">       <span class="comment">// 检查菊花</span></div><div class="line">       <span class="keyword">if</span> ([<span class="keyword">self</span> sd_showActivityIndicatorView]) &#123;</div><div class="line">           [<span class="keyword">self</span> sd_addActivityIndicator];</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// url 存在的情况下进行的操作...</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// url 为nil的情况下，生成错误信息，并返回         </span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           <span class="comment">// 移除菊花</span></div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>url不为nil的情况下，获取图片信息，并生成<code>operation</code>，然后存储。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回的是一个遵从了SDWebImageOperation协议的NSObject的子类，目的是方便之后的取消/移除操作</span></div><div class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123; <span class="comment">/*完成之后的操作*/</span> &#125;];</div><div class="line">        </div><div class="line">	<span class="comment">// 根据validOperationKey把生成的operation放入字典`SDOperationsDictionary`中，这个字典也是通过关联对象，作为UIView的一个属性。</span></div><div class="line">	[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</div></pre></td></tr></table></figure>
</li>
<li><p><code>SDInternalCompletionBlock</code>是在UIView内部使用的<code>completedBlock</code>，在block中，返回获取到的图片，以及相关信息。最后在主线程中，进行UI更新并更新布局。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// weak 避免 保留环</span></div><div class="line">   __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">   </div><div class="line">   <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">       </div><div class="line">       <span class="comment">// block 中强引用替换，避免使用过程中被系统自动释放</span></div><div class="line">       __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">       <span class="comment">// 加载完成移除菊花</span></div><div class="line">       [sself sd_removeActivityIndicator];</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> (!sself) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           <span class="keyword">if</span> (!sself) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// SDWebImageAvoidAutoSetImage, 对图片进行手动设置，开发者在外面的complete里面可以对图片设置特殊效果，然后赋值ImageView.image</span></div><div class="line">           <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">               completedBlock(image, error, cacheType, url);</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">               </div><div class="line">               <span class="comment">// 更新图片，内部会进行imageView或者button的判断</span></div><div class="line">               [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">               <span class="comment">// 更新布局Layout</span></div><div class="line">               [sself sd_setNeedsLayout];</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// SDWebImageDelayPlaceholder 延迟加载占位图，下载完成后才会进行设置</span></div><div class="line">               <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                   [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 如果有返回block，返回block和其它信息</span></div><div class="line">           <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">               completedBlock(image, error, cacheType, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="http://oeb4c30x3.bkt.clouddn.com/UIView+WebCache%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="UIView+WebCache流程图"></p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p><code>SDWebImageManager</code>起一个承上启下的作用，紧密连接图片下载<code>SDWebImageDownloader</code>和图片缓存<code>SDImageCache</code>，可以直接通过这个类获取缓存中的图片。</p>
<p>核心方法（也是<code>UIView+WebCache</code>的第6步）：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                              options:(SDWebImageOptions)options</div><div class="line">                                             progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                            completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure></p>
<p>内部实现：</p>
<ol>
<li><p>如果<code>completedBlock</code>为空，直接闪退并抛出错误信息。即，<code>completedBlock</code>不能为空。</p>
<ul>
<li><p><code>NSAssert</code>只有在<code>debug</code>状态下有效</p>
<pre><code>// Invoking this method without a completedBlock is pointless
    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);
</code></pre></li>
</ul>
</li>
<li><p>确保<code>url</code>是正确的，加安全验证，虽然<code>url</code>偶尔在字符串的情况下不报警告，但最好还是转换成<code>NSURL</code>类型，</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</div><div class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 防止url在某些特殊情况下（eg：NSNull）导致app闪退</span></div><div class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</div><div class="line">        url = nil;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先方法要返回的是遵从了<code>&lt;SDWebImageOperation&gt;</code>协议的对象，所以声明了一个对象<code>SDWebImageCombinedOperation</code>，该对象遵从了协议，下面会对其属性进行一一设置。<br>而<code>cancelled</code>属性是在<code>UIView+WebCache</code>第3点设置的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageNoParamsBlock cancelBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *cacheOperation;</div></pre></td></tr></table></figure>
<p>最后需要返回<code>operation</code>，所以进行创建、属性赋值、返回。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个SDWebImageCombinedOperation，加上 __block，可以让它在后续block内进行修改，</span></div><div class="line">    <span class="number">__</span>block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</div><div class="line">    <span class="comment">// 加上__weak 避免保留环</span></div><div class="line">    <span class="number">__</span><span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line">    </div><div class="line">	<span class="comment">/*</span></div><div class="line">	对operation 进行赋值操作，最后返回</div><div class="line">	*/</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> operation;</div></pre></td></tr></table></figure>
</li>
<li><p>再次对<code>url</code>进行判断，<code>failedURLs</code>类型是<code>NSMutableSet&lt;NSURL *&gt;</code>，是用来存储错误<code>url</code>的集合</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明一个BOOL值，isFailedUrl</span></div><div class="line">  <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line">  <span class="keyword">if</span> (url) &#123;</div><div class="line">      <span class="comment">// 创建一个同步锁，@synchronized&#123;&#125;它防止不同的线程同时执行同一段代码</span></div><div class="line">      <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">          <span class="comment">// 错误的url都会放在failedURLs 中，判断该url是否在里面,返回并赋值isFailedUrl</span></div><div class="line">          isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 如果url长度为0，或者 options中没有 SDWebImageRetryFailed（一直进行下载）， 并且是错误的url</span></div><div class="line">  <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">      </div><div class="line">      <span class="comment">// 不再向下执行，直接回调completeBlock，并传递错误信息，url不存在，NSURLErrorFileDoesNotExist</span></div><div class="line">      [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>] url:url];</div><div class="line">      <span class="keyword">return</span> operation;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>runningOperations</code>类型为<code>NSMutableArray&lt;SDWebImageCombinedOperation *&gt;</code>存储所有待执行的操作任务</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@synchronized</span> (self.runningOperations) &#123;</div><div class="line">        <span class="comment">// 把operation 存储起来</span></div><div class="line">        <span class="selector-attr">[self.runningOperations addObject:operation]</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在缓存中查找图片，并将找到的图片的相关信息返回，<br>同时对<code>operation.cacheOperation</code>属性赋值。<br>（该方法是<code>SDImageCache</code>类的实例方法，下篇再分析）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据url 返回一个本地用来缓存的标志 key</span></div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;	</div><div class="line">		 <span class="comment">// 查询结束后执行操作   </span></div><div class="line">     &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>缓存中是否查找到图片，分别处理：<br>a. 找不到图片，但是允许从网络下载，就进行网络下载</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果执行过程中操作取消，安全移除操作</span></div><div class="line"><span class="comment">// return 是跳出这个block</span></div><div class="line">   <span class="selector-tag">if</span> (operation.isCancelled) &#123;</div><div class="line">       <span class="selector-attr">[self safelyRemoveOperationFromRunning:operation]</span>;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 1. 如果不存在缓存图片，或者需要刷新缓存 2. 代理可以响应方法，或者代理直接执行该方法，即从网络下载图片</span></div><div class="line">   <span class="comment">// 1 和 2 是并且关系</span></div><div class="line">   <span class="selector-tag">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">imageManager</span>:<span class="attribute">shouldDownloadImageForURL</span>:)] || [self.delegate <span class="attribute">imageManager</span>:self <span class="attribute">shouldDownloadImageForURL</span>:url])) &#123; </div><div class="line">    		<span class="comment">//  网络下载图片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>b. 如果找到了缓存图片，回调图片及相关信息，操作结束，安全移除操作</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">       __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">       [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">       [self <span class="string">safelyRemoveOperationFromRunning:</span>operation];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>c. 缓存中找不到图片，也不允许网络下载图片：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">		  <span class="comment">// Image not in cache and download disallowed by delegate</span></div><div class="line">		  __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">		  [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">		  [self <span class="string">safelyRemoveOperationFromRunning:</span>operation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对a步骤一步步分析：如果有缓存图片，同时还要求刷新缓存，那么界面先加载缓存图片，然后网络下载，下载成功之后界面加载网络图片，然后在缓存中刷新之前的缓存图片</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">           </div><div class="line">		 <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">		 <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">		 <span class="comment">// 如果在缓存中找到了图片，但是设置了SDWebImageRefreshCached，因此要NSURLCache重新从服务器下载</span></div><div class="line">		 <span class="comment">// 先调用completeBlock后续进行网络下载</span></div><div class="line">		 [self <span class="string">callCompletionBlockForOperation:</span>weakOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据<code>SDWebImageOptions</code>的选项对<code>SDWebImageDownloaderOptions</code>进行对接，一一对应，协调处理。<code>|=</code> 可以理解为<code>添加</code><br><code>SDWebImageDownloaderOptions</code>的详细介绍点<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/SourceCode/SourceCode/libs/SDWebImage/SDWebImageDownloader.h" target="_blank" rel="external">这里</a></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">downloaderOptions <span class="string">|= SDWebImageDownloaderLowPriority</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">downloaderOptions = downloaderOptions <span class="string">| SDWebImageDownloaderLowPriority</span></div></pre></td></tr></table></figure>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// downloaderOptions 默认为0</span></div><div class="line"> SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">options</span> &amp; SDWebImageLowPriority)  downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">  </div><div class="line">    <span class="comment">// 如果需要刷新缓存，downloaderOptions强制解除SDWebImageDownloaderProgressiveDownload，并且添加SDWebImageDownloaderIgnoreCachedResponse选项</span></div><div class="line">  <span class="keyword">if</span> (cachedImage &amp;&amp; <span class="keyword">options</span> &amp; SDWebImageRefreshCached) &#123;</div><div class="line">	      <span class="comment">// force progressive off if image already cached but forced refreshing</span></div><div class="line">	      downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">	      <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></div><div class="line">	      downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过<code>url</code>进行网络下载图片：<br>每一个下载<code>SDWebImageDownloader</code>对象对应于一个<code>SDWebImageDownloadToken</code>对象，目的是用于取消/移除<code>SDWebImageDownloader</code>对象。<br>通过<code>SDWebImageDownloader</code>的实例方法生成一个<code>SDWebImageDownloadToken</code>对象。（该方法下篇分析）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line"><span class="comment">// 图片下载完成之后的操作。</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>对<code>operation.cancelBlock</code>赋值。<br>通过上面生成的<code>subOperationToken</code>来进行取消<code>SDWebImageDownloader</code>操作</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">operation.cancelBlock</span> = ^&#123;</div><div class="line">	      [<span class="keyword">self.imageDownloader </span>cancel:<span class="keyword">subOperationToken];</span></div><div class="line">	      __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span></div><div class="line">	      [<span class="keyword">self </span>safelyRemoveOperationFromRunning:<span class="keyword">strongOperation];</span></div><div class="line">  &#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>操作取消或者存在网络错误的情况下：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 操作不存在或者操作取消的情况下不做任何处理。</span></div><div class="line">__strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line"><span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">		<span class="comment">// https://github.com/rs/SDWebImage/pull/699</span></div><div class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</div><div class="line">	     [self callCompletionBlockForOperation:strongOperation completion:completedBlock <span class="built_in">error</span>:<span class="built_in">error</span> url:url];</div><div class="line">			<span class="comment">// 在下面情况下（不是因为网络问题），url本身有问题的情况下，才会添加进failedURLs</span></div><div class="line">	     <span class="keyword">if</span> (   <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNotConnectedToInternet</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCancelled</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorTimedOut</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorInternationalRoamingOff</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorDataNotAllowed</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotFindHost</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotConnectToHost) &#123;</div><div class="line">	         </div><div class="line">	         <span class="comment">// 跟前面第4点对应，failedURLs添加错误的url</span></div><div class="line">	         <span class="comment">@synchronized (self.failedURLs) &#123;</span></div><div class="line">	             [self.failedURLs addObject:url];</div><div class="line">	         &#125;</div><div class="line">	     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>成功情况下：<br>a. 对应于第8点，刷新缓存，并且图片下载失败的情况下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下载选项，允许失败后重新下载，</span></div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">options</span> &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">         <span class="comment">// 重新下载，得保证 url 是正确的，不在failedURLs里面</span></div><div class="line">         @<span class="keyword">synchronized</span> (self.failedURLs) &#123;</div><div class="line">             [self.failedURLs removeObject:url];</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 是否允许磁盘缓存</span></div><div class="line">     BOOL cacheOnDisk = !(<span class="keyword">options</span> &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">     <span class="comment">// 没有下载图片的情况下，不能刷新缓存</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">options</span> &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">         <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">         <span class="comment">// 对应于第8点，已经返回completeBlock，这里不做任何处理。</span></div><div class="line">         </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>b. 1. 有下载图片 2. 界面上下载图片尚未赋值，或者策略允许图片变换 3. 代理响应了图片变换操作<br>1，2，3 是并且关系。<br>图片先进行变换，然后缓存，最后回调</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">else</span> <span class="selector-tag">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">imageManager</span>:<span class="attribute">transformDownloadedImage</span>:<span class="attribute">withURL</span>:)]) &#123;</div><div class="line">	    <span class="comment">// 在全局队列（并发）中，开启一个子线程，异步执行，优先级比较高</span></div><div class="line">	    <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">	        <span class="comment">// 在缓存之前，就对图片进行处理变换，外层要手动实现代理方法</span></div><div class="line">	        UIImage *transformedImage = <span class="selector-attr">[self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]</span>;</div><div class="line">				<span class="comment">// 变换图片处理完成</span></div><div class="line">	        <span class="selector-tag">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">	        		<span class="comment">// 判断图片是否变换</span></div><div class="line">	            BOOL imageWasTransformed = !<span class="selector-attr">[transformedImage isEqual:downloadedImage]</span>;</div><div class="line">	            <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">	            <span class="comment">// 如果图片变换成功，imageData传nil，这样在缓存图片的时候，可以重新计算data大小，反之，就传downloadedData</span></div><div class="line">	            </div><div class="line">	            <span class="selector-attr">[self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]</span>;</div><div class="line">	        &#125;</div><div class="line">	        <span class="comment">// 回调信息</span></div><div class="line">	        [self <span class="attribute">callCompletionBlockForOperation</span>:strongOperation <span class="attribute">completion</span>:completedBlock <span class="attribute">image</span>:transformedImage <span class="attribute">data</span>:downloadedData <span class="attribute">error</span>:nil <span class="attribute">cacheType</span>:SDImageCacheTypeNone <span class="attribute">finished</span>:finished <span class="attribute">url</span>:url];</div><div class="line">	    &#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>c. 不对图片进行处理，直接缓存图片并回调。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">             [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</div><div class="line">         &#125;</div><div class="line">         [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><img src="http://oeb4c30x3.bkt.clouddn.com/SDWebImage%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="SDWebImageManager流程图"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Asynchronous image downloader with cache support as a UIImageView category&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;支持图片异步下载和缓存的UIImageView分类&lt;/p
    
    </summary>
    
      <category term="源码" scheme="http://lionwy.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="图片" scheme="http://lionwy.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="SDWebImage" scheme="http://lionwy.github.io/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>图片加载之AFNetwork（下）</title>
    <link href="http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://lionwy.github.io/图片加载之AFNetwork（下）/</id>
    <published>2016-10-19T09:52:56.000Z</published>
    <updated>2016-10-20T07:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AFImageDownloader"><a href="#AFImageDownloader" class="headerlink" title="AFImageDownloader"></a>AFImageDownloader</h2><blockquote>
<p>The AFImageDownloader class is responsible for downloading images in parallel on a prioritized queue. Incoming downloads are added to the front or back of the queue depending on the download prioritization. Each downloaded image is cached in the underlying NSURLCache as well as the in-memory image cache. By default, any download request with a cached image equivalent in the image cache will automatically be served the cached image representation.</p>
</blockquote>
<p>AFImageDownloader类是负责下载图片的，并且根据下载优先级，把新传入的下载添加在队列的前面或后面。每个下载好的图片不仅被缓存在底层的NSURLCache中（NSURLCache只是被用来自动缓存网络请求，并没有进行图片缓存），也缓存在内存中的图片缓存中（上篇写的AFAutoPurgingImageCache类）。默认情况下，如果请求的图片有缓存的话，会直接返回缓存图片。</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/research_2.jpg" alt="research_2.jpg"></p>
<p>1、简单了解下<code>AFImageDownloader</code>的主要属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.h 中可以被外部使用的属性</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache;<span class="comment">// 储存下载图片的对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPSessionManager *sessionManager;<span class="comment">// 进行数据请求的对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFImageDownloadPrioritization downloadPrioritizaton;<span class="comment">// 下载优先级</span></div><div class="line">.m 中不让外部调用的属性有：</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> maximumActiveDownloads;<span class="comment">// 同时处理线程的最大值，默认为4</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> activeRequestCount;<span class="comment">// 正在进行的请求数量，</span></div></pre></td></tr></table></figure>
<p>2、<code>AFImageDownloader</code> 有两个属性<code>queuedMergedTasks</code>，<code>mergedTasks</code>用来存储另一个对象<code>AFImageDownloaderMergedTask</code>（用来操作下载任务合并的对象）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;<span class="comment">// 数据请求的URL地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;<span class="comment">// 下载任务的唯一标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task; <span class="comment">// 处理数据请求任务的对象</span></div></pre></td></tr></table></figure>
<p>3、<code>AFImageDownloaderMergedTask</code>有一个属性<code>responseHandlers</code>来存储返回结果操作的对象<code>AFImageDownloaderResponseHandler</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;<span class="comment">// 合并任务的唯一标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);<span class="comment">// 成功块</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);<span class="comment">// 失败块</span></div></pre></td></tr></table></figure>
<p>4、返回到昨天那个处理图片下载的核心方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                                 withReceiptID:(<span class="built_in">NSUUID</span> *)receiptID</div><div class="line">                                                        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</div><div class="line">                                                        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
<p>返回值是<code>AFImageDownloadReceipt</code>，而它的声明方法只有一个，因此需要一个NSURLSessionDataTask对象（iOS 7.0 以后，代替<code>NSURLConnection</code>用来处理数据请求的类）<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@implementation <span class="type">AFImageDownloadReceipt</span></div><div class="line">- (instance<span class="keyword">type</span>)initWithReceiptID:(<span class="type">NSUUID</span> *)receiptID task:(<span class="type">NSURLSessionDataTask</span> *)task</div></pre></td></tr></table></figure></p>
<p>5、声明一个NSURLSessionDataTask对象，用来创建<code>AFImageDownloadReceipt</code>。<code>__block</code>修饰，用来在block中更改task值，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<p>6、在一个串行队列里中同步执行，直至结束，如果task存在，创建<code>AFImageDownloadReceipt</code>并返回，否则返回nil</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(self.synchronizationQueue, ^&#123; </div><div class="line">	// 在block中对<span class="keyword">task</span>进行赋值</div><div class="line">&#125;;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">task</span>) &#123;</div><div class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID <span class="keyword">task</span>:<span class="keyword">task</span>];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="keyword">return</span> nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7、再次对URLRequest进行判断</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</div><div class="line"><span class="comment">// 如果请求地址有误，直接就进行失败回调</span></div><div class="line"><span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (failure) &#123;</div><div class="line">      <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</div><div class="line">      <span class="comment">// 因为会有UI的交互，所以返回主线程处理failure</span></div><div class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">          failure(request, <span class="literal">nil</span>, error);</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// return 是跳出这个同步线程</span></div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8、如果请求已经存在，并且根据url地址能够找到AFImageDownloaderMergedTask，直接返回对应的task，然后外层赋值。</p>
<ul>
<li><p>这里可以看出来<code>AFImageDownloaderMergedTask</code>类的作用：</p>
<ol>
<li>当请求地址是同一个的时候，并且第一个请求正在进行中，后续就不再向服务器发送请求。这也是AFNetwork比较优化的一点，主要用来多张不同的imageView同时请求一个URL地址的情况。跟上篇那个同一张图片多次请求一个URL地址的情况比较一下（第6点）。</li>
<li>不同请求对应的成功失败块也没有统一处理，根据下载任务对应的唯一标识<code>receiptID</code>和成功失败块，生成<code>AFImageDownloaderResponseHandler</code>，来进行分别处理。</li>
<li>而合并任务的task就是外层需要的task，即创建<code>AFImageDownloadReceipt</code>的task</li>
</ol>
</li>
<li><p>如果是首次请求，后面肯定会有对应的赋值操作，往下看</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        </div><div class="line">   <span class="keyword">if</span> (existingMergedTask != nil) &#123;</div><div class="line">       <span class="comment">// AFImageDownloaderResponseHandler 用来处理返回结果的类</span></div><div class="line">       </div><div class="line">       AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] <span class="string">initWithUUID:</span>receiptID <span class="string">success:</span>success <span class="string">failure:</span>failure];</div><div class="line">       [existingMergedTask <span class="string">addResponseHandler:</span>handler];</div><div class="line">       task = existingMergedTask.task;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>9、 根据缓存策略在缓存中是否进行第二次的查找</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (request.cachePolicy) &#123;</div><div class="line">  <span class="comment">// 对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</div><div class="line">  <span class="comment">// 无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</div><div class="line">  <span class="comment">// 无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</div><div class="line">      <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</div><div class="line">      <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (success) &#123;</div><div class="line">              <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                  success(request, <span class="literal">nil</span>, cachedImage);</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>10、创建网络下载任务，进行图片下载，并处理返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 合并任务的唯一标识，</span></div><div class="line"><span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</div><div class="line"><span class="comment">// 声明一个数据请求任务</span></div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *createdTask;</div><div class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 返回数据请求任务</span></div><div class="line">createdTask = [<span class="keyword">self</span>.sessionManager</div><div class="line">             dataTaskWithRequest:request</div><div class="line">             uploadProgress:<span class="literal">nil</span></div><div class="line">             downloadProgress:<span class="literal">nil</span></div><div class="line">             completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123; </div><div class="line">             <span class="comment">// 数据下载完成后的处理</span></div><div class="line">             &#125;];</div></pre></td></tr></table></figure></p>
<p>11、对应第8点中的取值操作，这里进行赋值操作。注意一个关键字<code>mergedTaskIdentifier</code>，是合并任务的唯一标识</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] <span class="string">initWithUUID:</span>receiptID <span class="string">success:</span>success <span class="string">failure:</span>failure];</div><div class="line">        </div><div class="line">AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc] <span class="string">initWithURLIdentifier:</span>URLIdentifier <span class="string">identifier:</span>mergedTaskIdentifier <span class="string">task:</span>createdTask];</div><div class="line">   </div><div class="line">[mergedTask <span class="string">addResponseHandler:</span>handler];</div><div class="line">self.mergedTasks[URLIdentifier] = mergedTask;</div></pre></td></tr></table></figure>
<p>12、当前任务创建已经完成，根据线程中正在进行的请求数量来决定，是进行下一个任务，还是等待。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</div><div class="line">  [<span class="keyword">self</span> startMergedTask:mergedTask];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最后数据请求任务赋值</span></div><div class="line">task = mergedTask.task;</div></pre></td></tr></table></figure>
<p>13、下面线深入12中的方法，最后再啃硬骨头10中的方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正在进行的请求是否已经达到最大值（之前默认为4）</span></div><div class="line">- (BOOL)isActiveRequestCountBelowMaximumLimit &#123;</div><div class="line">    <span class="keyword">return</span> self.activeRequestCount &lt; self.maximumActiveDownloads;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果没有，任务就开始发起请求，并且更新当前请求数量的值</span></div><div class="line">- (<span class="keyword">void</span>)<span class="string">startMergedTask:</span>(AFImageDownloaderMergedTask *)mergedTask &#123;</div><div class="line">    [mergedTask.task resume];</div><div class="line">    ++self.activeRequestCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 暂时挂起数据任务，然后按顺序放入数组中，直到有空余的线程来处理数据请求任务</span></div><div class="line">- (<span class="keyword">void</span>)<span class="string">enqueueMergedTask:</span>(AFImageDownloaderMergedTask *)mergedTask &#123;</div><div class="line">    <span class="keyword">switch</span> (self.downloadPrioritizaton) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">AFImageDownloadPrioritizationFIFO:</span><span class="comment">// 先进先出，放入数组后面</span></div><div class="line">            [self.queuedMergedTasks <span class="string">addObject:</span>mergedTask];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">AFImageDownloadPrioritizationLIFO:</span><span class="comment">// 后进先出，放入数组的第一个，优先处理</span></div><div class="line">            [self.queuedMergedTasks <span class="string">insertObject:</span>mergedTask <span class="string">atIndex:</span><span class="number">0</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>14、最后来处理当图片下载任务（即网络请求任务）已经完成，之后的操作</p>
<ol>
<li><p>首先请求结果的处理都是在异步线程中执行的，避免线程阻塞，一直在等待网络请求完成 </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dispatch_async</span>(<span class="selector-tag">self</span><span class="selector-class">.responseQueue</span>, ^&#123; &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>针对第8点，第11点，所有针对返回结果的操作都是跟<code>AFImageDownloaderMergedTask</code>绑定的，所以找到对应于url地址的合并任务，并且根据合并任务的唯一标识判断是否同一个，</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderMergedTask *mergedTask = self.mergedTasks<span class="string">[URLIdentifier]</span>;</div><div class="line">                               </div><div class="line">	if (<span class="string">[mergedTask.identifier isEqual:mergedTaskIdentifier]</span>) &#123;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>跟之前从字典获取的其实是同一个合并任务，这句话主要用来任务完成了，在字典中移除键值对</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">mergedTask</span> = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</div></pre></td></tr></table></figure>
</li>
<li><p>遍历同一个url对应的所有的失败块，都失败了，回调失败信息</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 失败处理</span></div><div class="line"><span class="selector-tag">if</span> (error) &#123;</div><div class="line"></div><div class="line">	    <span class="selector-tag">for</span> (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">	        <span class="selector-tag">if</span> (handler.failureBlock) &#123;</div><div class="line">	            <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">	                handler<span class="selector-class">.failureBlock</span>(request, (NSHTTPURLResponse*)response, error);</div><div class="line">	            &#125;);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>成功情况下，先进行图片缓存，再对所有的成功块，进行成功信息回调</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="name">strongSelf.imageCache</span> addImage:responseObject forRequest:request withAdditionalIdentifier:nil]<span class="comment">;</span></div><div class="line"></div><div class="line">	for (<span class="name">AFImageDownloaderResponseHandler</span> *handler in mergedTask.responseHandlers) &#123;</div><div class="line">	   // 成功回调处理</div><div class="line">	   if (<span class="name">handler.successBlock</span>) &#123;</div><div class="line">	       dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</div><div class="line">	           handler.successBlock(<span class="name">request</span>, (<span class="name">NSHTTPURLResponse*</span>)response, responseObject)<span class="comment">;</span></div><div class="line">	       &#125;)<span class="comment">;</span></div><div class="line">	   &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后，请求结束了，当前执行的请求数量-1，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</div><div class="line">	    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</div><div class="line">	            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果还有需要执行的线程，就启动下一个线程</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">safelyStartNextTaskIfNecessary</span> &#123;</div><div class="line">	    <span class="selector-tag">dispatch_sync</span>(self.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="selector-tag">if</span> ([self isActiveRequestCountBelowMaximumLimit]) &#123;</div><div class="line">	            <span class="selector-tag">while</span> (self.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</div><div class="line">	                AFImageDownloaderMergedTask *mergedTask = <span class="selector-attr">[self dequeueMergedTask]</span>;</div><div class="line">	                <span class="selector-tag">if</span> (mergedTask.task.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">	                    <span class="selector-attr">[self startMergedTask:mergedTask]</span>;</div><div class="line">	                    break;</div><div class="line">	                &#125;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>目前这就是AFNetwork中加载图片的所有流程，当然数据请求还没有涉及，想研究这个入口的时候再进行深入<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                      progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))uploadProgress</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. AFNetwork把加载图片的任务都放入一个字典中，然后把任务对应的网络请求放入数组中，然后按顺序执行</em></strong></p>
<p><strong><em>2. 在图片加载过程中，除了在针对请求结果处理的时候是异步进行的，其他全是同步进行的</em></strong></p>
<p><strong><em>3. 一家之言，请多指教</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AFImageDownloader&quot;&gt;&lt;a href=&quot;#AFImageDownloader&quot; class=&quot;headerlink&quot; title=&quot;AFImageDownloader&quot;&gt;&lt;/a&gt;AFImageDownloader&lt;/h2&gt;&lt;blockquote&gt;

    
    </summary>
    
      <category term="源码" scheme="http://lionwy.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="AFNetwork" scheme="http://lionwy.github.io/tags/AFNetwork/"/>
    
      <category term="图片" scheme="http://lionwy.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>图片加载之AFNetwork（上）</title>
    <link href="http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://lionwy.github.io/图片加载之AFNetwork（上）/</id>
    <published>2016-10-18T09:40:26.000Z</published>
    <updated>2016-10-20T07:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIImageView-AFNetworking"><a href="#UIImageView-AFNetworking" class="headerlink" title="UIImageView+AFNetworking"></a>UIImageView+AFNetworking</h2><blockquote>
<p>This category adds methods to the UIKit framework’s UIImageView class. The methods in this category provide support for loading remote images asynchronously from a URL.</p>
</blockquote>
<p>给UIImageView添加分类方法，通过一个URL异步加载远程图片</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/research.jpg" alt="research.jpg"></p>
<ol>
<li><p>核心方法就是下面很简单的方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url;</div></pre></td></tr></table></figure>
</li>
<li><p>内部实现，创建图片请求，并在请求头添加参数,后续的所有操作都是跟request有关</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">setImageWithURL:</span>(NSURL *)url</div><div class="line"><span class="symbol">       placeholderImage:</span>(UIImage *)placeholderImage</div><div class="line">&#123;</div><div class="line">	    NSMutableURLRequest *request = [NSMutableURLRequest <span class="string">requestWithURL:</span>url];</div><div class="line">	    [request <span class="string">addValue:</span>@<span class="string">"image/*"</span> <span class="string">forHTTPHeaderField:</span>@<span class="string">"Accept"</span>];</div><div class="line">	</div><div class="line">	    [self <span class="string">setImageWithURLRequest:</span>request <span class="string">placeholderImage:</span>placeholderImage <span class="string">success:</span>nil <span class="string">failure:</span>nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面两个方法最终调用的都是下面的方法，下面就针对最核心的方法，一步步分析它的具体实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</div><div class="line">              placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</div><div class="line">                       success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</div><div class="line">                       failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
</li>
<li><p>在任何请求发生之前，都要进行URLRequest的判断。如果URL为空，就取消图片下载任务，并直接设置占位图</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="regexp">//</span> 对于当前的这个任务，取消所有正在执行的图片下载操作，并把下载回执置空</div><div class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.image = placeholderImage;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面方法里面涉及到两个类<code>AFImageDownloadReceipt</code> <code>AFImageDownloader</code></p>
<ul>
<li><p>首先需要明白一个规则：图片下载任务的取消不是由任务自己取消，而是通过“下载回执”取消</p>
</li>
<li><p>AFImageDownloader：用来处理图片下载的类，所有下载任务都由它处理</p>
</li>
<li><p>AFImageDownloadReceipt：“下载回执”，跟AFImageDownloader一一对应，主要是用来取消AFImageDownloader正在运行的任务，只有两个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;<span class="comment">// 下载任务，即AFImageDownloader执行的任务</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;<span class="comment">//任务的唯一标识，用来区分两个任务是否相同</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>根据<code>URLRequest</code>来判断两次请求是否同一个，即，阻止同一张图片进行多次相同的请求，优化请求。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> <span class="symbol">isActiveTaskURLEqualToURLRequest:</span>urlRequest])&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>AFImageRequestCache</code>协议，是用来添加、删除、访问图片。这里把下载器存储图片的对象赋值给一个支持该协议的对象，用来获取缓存图片</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>通过URLrequest在缓存中查找图片，如果能找到，就返回缓存图片，操作结束。缓存见<a href="https://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%80%EF%BC%89/#AFAutoPurgingImageCache">这里</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">        <span class="comment">// 如果需要返回结果，就进行回调，在回调block中进行手动设置imageView.image</span></div><div class="line">        <span class="keyword">if</span> (success) &#123;</div><div class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.image = cachedImage;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 操作已经完成，把下载回执置空，</span></div><div class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</div><div class="line">     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果有占位图，就先设置占位图。<code>NSUUID</code>是用来创建唯一标识的，每次调用<code>UUID</code>返回结果都不一样，对应于下载回执的任务标识<code>receiptID</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (placeholderImage) &#123;</div><div class="line">  		<span class="keyword">self</span>.image = placeholderImage;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 弱引用，防止保留环</span></div><div class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</div></pre></td></tr></table></figure>
</li>
<li><p>根据<code>URLrequest</code>和<code>receiptID</code>进行图片下载，返回的是对应下载操作的回执<code>AFImageDownloadReceipt</code>，具体实现下一篇马上呈现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                                 withReceiptID:(<span class="built_in">NSUUID</span> *)receiptID</div><div class="line">                                                        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</div><div class="line">                                                        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
</li>
<li><p>获取图片成功的情况下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 首先在<span class="keyword">block中，强引用下，避免在运行过程中，self被自动释放</span></div><div class="line">   __strong __typeof(weakSelf)<span class="keyword">strongSelf </span>= weakSelf<span class="comment">;</span></div><div class="line">   // 根据任务标识判断，避免返回结果对应的请求不是之前的那个请求</div><div class="line">   <span class="meta">if</span> ([<span class="keyword">strongSelf.af_activeImageDownloadReceipt.receiptID </span>isEqual:downloadID]) &#123;</div><div class="line">   	   // 如果有成功块，就返回成功块，并在<span class="keyword">block中手动设置图片</span></div><div class="line">       <span class="meta">if</span> (success) &#123;</div><div class="line">           success(request, response, responseObject)<span class="comment">;</span></div><div class="line">       &#125; <span class="meta">else</span> <span class="meta">if</span>(responseObject) &#123;</div><div class="line">           <span class="keyword">strongSelf.image </span>= responseObject<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line">       // 操作完成，下载回执置空</div><div class="line">       [<span class="keyword">strongSelf </span>clearActiveDownloadInformation]<span class="comment">;</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>失败情况下，返回错误信息，并清空下载信息</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"><span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">   <span class="keyword">if</span> (failure) &#123;</div><div class="line">       failure(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">error</span>);</div><div class="line">   &#125;</div><div class="line">   [strongSelf clearActiveDownloadInformation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>把返回的下载回执，赋值给图片对应的下载回执，对应最开始的第6点，也就是说，当一张图片正在进行下载操作，如果再进行一次相同的请求，那么第二次请求直接返回，继续执行第一次的请求，直到请求结束，然后赋值。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.af_activeImageDownloadReceipt = receipt<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AFAutoPurgingImageCache"><a href="#AFAutoPurgingImageCache" class="headerlink" title="AFAutoPurgingImageCache"></a>AFAutoPurgingImageCache</h2><blockquote>
<p>The AutoPurgingImageCache in an in-memory image cache used to store images up to a given memory capacity. When the memory capacity is reached, the image cache is sorted by last access date, then the oldest image is continuously purged until the preferred memory usage after purge is met. Each time an image is accessed through the cache, the internal access date of the image is updated.</p>
</blockquote>
<p>这个类是用来在内存中进行图片缓存操作的，并且会根据图片使用时间排序，当内存快满的时候，先释放最久未使用的图片，然后再清除优先使用内存里面的图片。每次使用图片后，图片使用时间都会更新。<br>这个类遵循<code>AFImageRequestCache</code>协议，因此可以使用协议方法</p>
<ol>
<li><p>内存分类：默认内存100M，优先使用内存60M。并且使用<code>cachedImages</code>来存储所有的图片对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> memoryCapacity;<span class="comment">//总内存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> preferredMemoryUsageAfterPurge;<span class="comment">//优先使用内存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">UInt64</span> memoryUsage;<span class="comment">//内存已使用容量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> &lt;<span class="built_in">NSString</span>* , AFCachedImage*&gt; *cachedImages;<span class="comment">//可变字典来存储图片对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage;<span class="comment">//当前内存使用情况，跟memoryUsage一样的</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> synchronizationQueue;<span class="comment">//同步线程</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里涉及到一个类<code>AFCachedImage</code>，用来存储图片以及图片信息的类</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;<span class="comment">//图片</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;<span class="comment">//图片标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;<span class="comment">//图片大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;<span class="comment">//最新使用日期</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage;<span class="comment">//当前内存已使用容量</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里有个方法可以学习下，如何计算图片所占内存</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据屏幕进行等比例的缩减/扩大图片size</span></div><div class="line">CGSize imageSize = CGSizeMake(<span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="built_in">image</span>.<span class="built_in">scale</span>, <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">scale</span>);</div><div class="line">CGFloat bytesPerPixel = <span class="number">4.0</span>;</div><div class="line">CGFloat bytesPerSize = imageSize.<span class="built_in">width</span> * imageSize.<span class="built_in">height</span>;</div><div class="line">self.totalBytes = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;</div></pre></td></tr></table></figure>
</li>
<li><p>回到上面那个协议方法，返回一个对应于<code>request</code>和<code>identifier</code>的图片</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure>
</li>
<li><p>图片的Identifier，直接拼接url和additionalIdentifier</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</div><div class="line">	    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</div><div class="line">	    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>)</div><div class="line">	    &#123;</div><div class="line">	        key = [key stringByAppendingString:additionalIdentifier];</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据图片的Identifier，在可变字典中获取需要的图片，并更新使用时间。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</div><div class="line">	    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</div><div class="line">	    <span class="comment">// 同步操作，获取缓存图片</span></div><div class="line">	    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="comment">// 用来存储图片信息的类</span></div><div class="line">	        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</div><div class="line">	        image = [cachedImage accessImage];</div><div class="line">	    &#125;);</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内存中添加图片，使用栅栏保证线程安全，栅栏即，把之前所有的事情处理完毕之后，再进行栅栏中的处理，栅栏处理完成之后，再进行后续的处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">    <span class="comment">// 根据图片和标识，生成图片信息类</span></div><div class="line">    AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</div><div class="line">    <span class="comment">// 根据标识查找是否已经存在对应的图片</span></div><div class="line">    AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</div><div class="line">    <span class="comment">// 如果已经存在，先减少图片所占内存</span></div><div class="line">    <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 再更新图片，和内存使用情况</span></div><div class="line">    <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</div><div class="line">    <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如果内存满了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</div><div class="line">        <span class="comment">// 1. 需要清除的缓存大小</span></div><div class="line">        <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 先把可变字典里面所有的图片信息类放入数组，然后根据最新使用时间进行排序 </span></div><div class="line">        <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</div><div class="line">        <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"lastAccessDate"</span> ascending:<span class="literal">YES</span>];</div><div class="line">        [sortedImages sortUsingDescriptors:@[sortDescriptor]];</div><div class="line"></div><div class="line">        <span class="comment">// 3. 默认已经清除的缓存</span></div><div class="line">        <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 4. 一张张图片进行清除，然后更新已经清除的缓存容量，直到符合要求</span></div><div class="line">        <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</div><div class="line">            [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</div><div class="line">            bytesPurged += cachedImage.totalBytes;</div><div class="line">            <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</div><div class="line">                <span class="keyword">break</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 5. 更新当前内存已使用容量</span></div><div class="line">        <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. AFNetwork中图片的缓存，自定义了一个对象<code>AFAutoPurgingImageCache</code>，在对象中声明了一个可变数组来进行图片的增删改查</em></strong></p>
<p><strong><em>2. AFAutoPurgingImageCache并没有磁盘缓存，也没有本地缓存，程序一旦重启，就需要重新进行缓存的处理</em></strong></p>
<p><strong><em>3. 源码阅读，要找到一个入口，静下心来看</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UIImageView-AFNetworking&quot;&gt;&lt;a href=&quot;#UIImageView-AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;UIImageView+AFNetworking&quot;&gt;&lt;/a&gt;UIImageView+AF
    
    </summary>
    
      <category term="源码" scheme="http://lionwy.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="AFNetwork" scheme="http://lionwy.github.io/tags/AFNetwork/"/>
    
      <category term="图片" scheme="http://lionwy.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>记录Effective Objective-C 2.0 笔记目录</title>
    <link href="http://lionwy.github.io/%E8%AE%B0%E5%BD%95Effective%20Objective-C%202.0%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://lionwy.github.io/记录Effective Objective-C 2.0 笔记/</id>
    <published>2016-10-11T09:04:50.000Z</published>
    <updated>2016-10-11T09:40:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Effective Objective-C 这本书只要认真看了的都会明白里面的东西有多重要</p>
</blockquote>
<ul>
<li>目前正在看第二遍，顺便写下自己的读书笔记，起个记录和提醒的作用，内容主要是简单总结，很少有例子，如果不清楚的，强烈建议看原书。当然对于电子书爱好者，<a href="https://pan.baidu.com/s/1gePb0Uv" target="_blank" rel="external">这里</a>分享下电子书版本。</li>
</ul>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/download.jpg" alt=""></p>
<h1 id="第一章-熟悉Objective-C"><a href="#第一章-熟悉Objective-C" class="headerlink" title="第一章 熟悉Objective-C"></a>第一章 熟悉Objective-C</h1><blockquote>
<p>OC是在C语言的基础上添加了面向对象特性</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/1.%E4%BA%86%E8%A7%A3Objective-C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90.md#%E4%BA%86%E8%A7%A3objective-c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90" target="_blank" rel="external">1、Objective-C的起源、本质</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/2.%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6.md#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6" target="_blank" rel="external">2、@class or import</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/3.%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%B0%91%E7%94%A8%E4%B8%8E%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%9A%84%E6%96%B9%E6%B3%95.md#%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%B0%91%E7%94%A8%E4%B8%8E%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="external">3、使用<code>@</code>字面量语法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/4.%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%B0%91%E7%94%A8%23define%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.md#%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B0%91%E7%94%A8define%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4" target="_blank" rel="external">4、如何使用宏define</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/5.%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E3%80%81%E9%80%89%E9%A1%B9%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81.md#%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E9%80%89%E9%A1%B9%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">5、枚举</a></p>
<h1 id="第二章-对象、消息、运行期"><a href="#第二章-对象、消息、运行期" class="headerlink" title="第二章 对象、消息、运行期"></a>第二章 对象、消息、运行期</h1><blockquote>
<ol>
<li>面向对象语言中，对象就是“基本构造单元”（building block），开发者通过对象来存储并传递数据。</li>
<li>对象之间传递数据并执行任务的过程就是“消息传递”（messaging）</li>
<li>运行期环境：就是开发者编写的代码，提供了一些使得对象之间能够传递消息的重要函数了，并且包含创建类实例所用的全部逻辑</li>
</ol>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/6.%E7%90%86%E8%A7%A3%E2%80%9C%E5%B1%9E%E6%80%A7%E2%80%9D.md#%E7%90%86%E8%A7%A3%E5%B1%9E%E6%80%A7" target="_blank" rel="external">6、copy、strong属性</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/7.%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E5%B0%BD%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F.md#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E5%B0%BD%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F" target="_blank" rel="external">7、<code>.</code>语法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/8.%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E7%AD%89%E5%90%8C%E6%80%A7.md#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E7%AD%89%E5%90%8C%E6%80%A7" target="_blank" rel="external">8、判断对象相等<code>=</code></a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/9.%E4%BB%A5%E7%B1%BB%E7%B0%87%E6%A8%A1%E5%BC%8F%E9%9A%90%E8%97%8F%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82.md#%E4%BB%A5%E7%B1%BB%E7%B0%87%E6%A8%A1%E5%BC%8F%E9%9A%90%E8%97%8F%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82" target="_blank" rel="external">9、类簇和工厂模式</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/10.%E5%9C%A8%E6%97%A2%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE.md#%E5%9C%A8%E6%97%A2%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE" target="_blank" rel="external">10、关联属性</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/11.%E7%90%86%E8%A7%A3objc_msgSend%E7%9A%84%E4%BD%9C%E7%94%A8.md#%E7%90%86%E8%A7%A3objc_msgsend%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="external">11、OC的消息发送</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/12.%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6.md#%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91" target="_blank" rel="external">12、消息转发</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/13.%E7%94%A8%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%E6%8A%80%E6%9C%AF%E8%B0%83%E8%AF%95%E9%BB%91%E7%9B%92%E6%96%B9%E6%B3%95.md#%E7%94%A8%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%E6%8A%80%E6%9C%AF%E8%B0%83%E8%AF%95%E9%BB%91%E7%9B%92%E6%96%B9%E6%B3%95" target="_blank" rel="external">13、黑魔法method swizzling</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/14.%E7%90%86%E8%A7%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%84%8F.md#%E7%90%86%E8%A7%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%84%8F" target="_blank" rel="external">14、OC对象</a></p>
<h1 id="第三章-接口与API设计"><a href="#第三章-接口与API设计" class="headerlink" title="第三章 接口与API设计"></a>第三章 接口与API设计</h1><blockquote>
<p>如果要重用代码，就需要在编写接口的时候将其设计成易于复用的形式，包括命名、编码规范等。</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/15.%E7%94%A8%E5%89%8D%E7%BC%80%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81.md#%E7%94%A8%E5%89%8D%E7%BC%80%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81" target="_blank" rel="external">15、命名前缀</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/16.%E6%8F%90%E4%BE%9B%E5%85%A8%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95.md#%E6%8F%90%E4%BE%9B%E5%85%A8%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95" target="_blank" rel="external">16、init</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/17.%E5%AE%9E%E7%8E%B0description%E6%96%B9%E6%B3%95.md#%E5%AE%9E%E7%8E%B0description%E6%96%B9%E6%B3%95" target="_blank" rel="external">17、description</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/18.%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1.md#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">18、readonly</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/19.%E4%BD%BF%E7%94%A8%E6%B8%85%E6%99%B0%E8%80%8C%E5%8D%8F%E8%B0%83%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F.md#%E4%BD%BF%E7%94%A8%E6%B8%85%E6%99%B0%E8%80%8C%E5%8D%8F%E8%B0%83%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F" target="_blank" rel="external">19、怎么起名字</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/20.%E4%B8%BA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E5%8A%A0%E5%89%8D%E7%BC%80.md#%E4%B8%BA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E5%8A%A0%E5%89%8D%E7%BC%80" target="_blank" rel="external">20、私有方法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/21.%E7%90%86%E8%A7%A3Objective-C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B.md#%E7%90%86%E8%A7%A3oc%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">21、异常和error</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/22.%E7%90%86%E8%A7%A3NSCoping%E5%8D%8F%E8%AE%AE.md#%E7%90%86%E8%A7%A3nscoping%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">22、copy 是浅拷贝还是很拷贝</a></p>
<h1 id="第四章-协议与分类"><a href="#第四章-协议与分类" class="headerlink" title="第四章 协议与分类"></a>第四章 协议与分类</h1><blockquote>
<p>OC不支持多重继承（继承不同的类），因此我们把某个类应该实现的一系列方法定义在协议里面。<br>OC运行期系统是高度动态的，因此可以利用分类，无需继承子类即可直接为当前类添加方法。</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/23.%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E9%80%9A%E4%BF%A1.md#%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="external">23、协议 delegate</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/24-27%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BD.md#24-%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B9%8B%E4%B8%AD" target="_blank" rel="external">24-27、用好分类category</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/28.%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1.md#%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">28、<code>id</code>匿名对象</a></p>
<h1 id="第五章-内存管理"><a href="#第五章-内存管理" class="headerlink" title="第五章 内存管理"></a>第五章 内存管理</h1><p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/29%E3%80%8136.%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.md#%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">29、36、向<code>retainCount</code>say NO</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/30.%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.md#%E4%BB%A5arc%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">30、什么是ARC</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/31.%E5%9C%A8dealloc%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC.md#%E5%9C%A8dealloc%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC" target="_blank" rel="external">31、<code>dealloc</code>里面干什么</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/33.%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF.md#%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF" target="_blank" rel="external">33、循环引用的解决方案</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/34.%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%9D%97%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC.md#%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC" target="_blank" rel="external">34、简单了解下@autoreleasepool</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/35.%E7%94%A8%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98.md#%E7%94%A8%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98" target="_blank" rel="external">35、僵尸对象到底是什么</a></p>
<h1 id="第六章-块与大中枢派发"><a href="#第六章-块与大中枢派发" class="headerlink" title="第六章 块与大中枢派发"></a>第六章 块与大中枢派发</h1><blockquote>
<ul>
<li>块（block）是一种可在C、C++及OC代码中使用的词法闭包，借由块，开发者可将代码像对象一样传递。</li>
<li>GCD提供了对线程的抽象，这种抽象基于“派发队列”（dispatch queue）。GCD会根据系统资源情况，适时地创建、复用、摧毁后台线程，以便处理每个队列。</li>
</ul>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/37.%E7%90%86%E8%A7%A3%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5.md#%E7%90%86%E8%A7%A3%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5" target="_blank" rel="external">37、block概念</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/38.%E4%B8%BA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BAtypedef.md#%E4%B8%BA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BAtypedef" target="_blank" rel="external">38、声明block</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/39.%E7%94%A8handler%E5%9D%97%E9%99%8D%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E7%A8%8B%E5%BA%A6.md#%E7%94%A8handler%E5%9D%97%E9%99%8D%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E7%A8%8B%E5%BA%A6" target="_blank" rel="external">39、block or delegate</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/41.%E5%A4%9A%E7%94%A8%E6%B4%BE%E5%8F%91%E9%98%9F%E5%88%97%EF%BC%8C%E5%B0%91%E7%94%A8%E5%90%8C%E6%AD%A5%E9%94%81.md#%E5%A4%9A%E7%94%A8%E6%B4%BE%E5%8F%91%E9%98%9F%E5%88%97%E5%B0%91%E7%94%A8%E5%90%8C%E6%AD%A5%E9%94%81" target="_blank" rel="external">41、iOS中的锁</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/42.%E5%A4%9A%E7%94%A8GCD%EF%BC%8C%E5%B0%91%E7%94%A8performSelector%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95.md#%E5%A4%9A%E7%94%A8gcd%E5%B0%91%E7%94%A8performselector%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95" target="_blank" rel="external">42、GCD 取代 performSelector
</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/43.%E6%8E%8C%E6%8F%A1GCD%E5%8F%8A%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA.md#%E6%8E%8C%E6%8F%A1gcd%E5%8F%8A%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA" target="_blank" rel="external">43、NSOperation</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/44.%E9%80%9A%E8%BF%87Dispatch%20Group%20%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%8A%B6%E5%86%B5%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.md#%E9%80%9A%E8%BF%87dispatch-group%E6%9C%BA%E5%88%B6%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%8A%B6%E5%86%B5%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1" target="_blank" rel="external">44、dispatch group 的方法简介</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/45.%E4%BD%BF%E7%94%A8dispatch_once%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%8F%AA%E9%9C%80%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81.md#%E4%BD%BF%E7%94%A8dispatch_once%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%8F%AA%E9%9C%80%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81" target="_blank" rel="external">45、dispatch_once 实现单例</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/46.%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8dispatch_get_current_queue.md#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8dispatch_get_current_queue" target="_blank" rel="external">46、废弃的dispatch_get_current_queue
</a></p>
<h1 id="第七章-系统框架"><a href="#第七章-系统框架" class="headerlink" title="第七章 系统框架"></a>第七章 系统框架</h1><blockquote>
<p>只要编写OC代码，就离不开系统框架</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/47.%E7%86%9F%E6%82%89%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.md#%E7%86%9F%E6%82%89%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6" target="_blank" rel="external">47、熟悉系统框架</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/48.%E5%A4%9A%E7%94%A8%E5%9D%97%E6%9E%9A%E4%B8%BE%EF%BC%8C%E5%B0%91%E7%94%A8for%E5%BE%AA%E7%8E%AF.md#%E5%A4%9A%E7%94%A8%E5%9D%97%E6%9E%9A%E4%B8%BE%E5%B0%91%E7%94%A8for%E5%BE%AA%E7%8E%AF" target="_blank" rel="external">48、四个遍历方法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/49.%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89%E7%9A%84collection%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BC%9D%E6%A1%A5%E6%8E%A5.md#%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89%E7%9A%84collection%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BC%9D%E6%A1%A5%E6%8E%A5" target="_blank" rel="external">49、使用__bridge无缝桥接</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/50.%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E6%97%B6%E9%80%89%E7%94%A8NSCache%E8%80%8C%E9%9D%9ENSDictionary.md#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E6%97%B6%E9%80%89%E7%94%A8nscache%E8%80%8C%E9%9D%9Ensdictionary" target="_blank" rel="external">50、缓存NSCache</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/51.%E7%B2%BE%E7%AE%80initialize%E4%B8%8Eload%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81.md#%E7%B2%BE%E7%AE%80initialize%E4%B8%8Eload%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" target="_blank" rel="external">51、你应该了解的initialize与load</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/52.%E5%88%AB%E5%BF%98%E4%BA%86NSTimer%E4%BC%9A%E4%BF%9D%E7%95%99%E5%85%B6%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.md#%E5%88%AB%E5%BF%98%E4%BA%86nstimer%E4%BC%9A%E4%BF%9D%E7%95%99%E5%85%B6%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">52、NSTimer的小知识</a></p>
<p>[终]</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Effective Objective-C 这本书只要认真看了的都会明白里面的东西有多重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;目前正在看第二遍，顺便写下自己的读书笔记，起个记录和提醒的作用，内容主要是简单总结，很少有例子，如果不
    
    </summary>
    
      <category term="书架" scheme="http://lionwy.github.io/categories/%E4%B9%A6%E6%9E%B6/"/>
    
    
      <category term="读书学习" scheme="http://lionwy.github.io/tags/%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OC原理" scheme="http://lionwy.github.io/tags/OC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 常用命令</title>
    <link href="http://lionwy.github.io/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://lionwy.github.io/Hexo常用命令/</id>
    <published>2016-09-26T09:40:36.000Z</published>
    <updated>2016-10-28T08:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h1><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<ol>
<li><p>把本地文件上传blog</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre></li>
<li><p>新建文章</p>
<pre><code>hexo new “文章题目”
</code></pre></li>
<li><p>新建另一页（如关于，标签，分类）</p>
<pre><code>hexo new page &quot;about&quot;
</code></pre></li>
<li><p>分类下显示你所编写的标签</p>
<pre><code>---
title: categories
date: 2016-09-14 11:54:11
type: &quot;categories&quot; #这句话不能少
comments: false   #去除多说评论框

---
</code></pre></li>
<li><p>添加多说评论</p>
<ul>
<li><p><a href="http://duoshuo.com/" target="_blank" rel="external">多说官网</a> “我要安装”</p>
</li>
<li><p>在 next 主题设置shortName</p>
<pre><code># Duoshuo ShortName #不能去掉注释 
duoshuo_shortname: your_short_name
</code></pre></li>
</ul>
</li>
<li><p>文章添加多个标签</p>
<pre><code>tags: [tag1,tag2,tag3] #冒号后面添加空格
</code></pre></li>
<li><p>关于标题设置</p>
<pre><code>~/Hexo/themes/next/layout/index.swig 
</code></pre></li>
</ol>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!--设置的标题 + 主题的描述--&gt;</span></span></div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; theme.description &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div><div class="line">		</div><div class="line"><span class="comment">&lt;!--主题关键字 + 标题 + 主题描述--&gt;</span>		</div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; theme.keywords &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; theme.description &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div><div class="line">		</div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo-常用命令&quot;&gt;&lt;a href=&quot;#Hexo-常用命令&quot; class=&quot;headerlink&quot; title=&quot;Hexo 常用命令&quot;&gt;&lt;/a&gt;Hexo 常用命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-c
    
    </summary>
    
      <category term="博客" scheme="http://lionwy.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://lionwy.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
